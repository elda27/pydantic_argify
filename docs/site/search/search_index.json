{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pydantic-argparse-builder","text":"<p>Build ArgumentParser from pydantic model.</p>"},{"location":"#whats-difference-with-other-projects","title":"What's difference with other projects.","text":"<p>This project focuses on creating an argument parser from the pydantic model. Many other projects hide <code>ArgumentParser</code> in the library, but it is difficult to use in complicated cases. For example nested sub parser; i.e. <code>aws s3 cp &lt;some options&gt;</code>, or nested pydantic model is not supported. This library achieve that you can easily add complicate uses.</p>"},{"location":"#example-1","title":"Example 1","text":"<pre><code>from argparse import ArgumentParser\nfrom pydantic import BaseModel, Field\nfrom pydantic_argparse_builder import build_parser\nclass Config(BaseModel):\nstring: str = Field(description=\"string parameter\")\ninteger: int = Field(description=\"integer parameter\")\nparser = ArgumentParser()\nbuild_parser(parser)\nparser.print_help()\n</code></pre> <pre><code>usage: basic.py [-h] --string STRING --integer INTEGER\n\noptional arguments:\n  -h, --help            show this help message and exit\n\nConfig:\n  --string STRING, -s STRING\n                        a required string\n  --integer INTEGER, -i INTEGER\n                        a required integer\n</code></pre>"},{"location":"#example-2","title":"Example 2","text":"<pre><code>from argparse import ArgumentParser\nfrom pydantic import BaseModel, Field\nfrom pydantic_argparse_builder import build_parser\nclass SubConfigA(BaseModel):\nstring: str = Field(description=\"string parameter\")\ninteger: int = Field(description=\"integer parameter\")\nclass SubConfigB(BaseModel):\ndouble: float = Field(description=\"a required string\")\ninteger: int = Field(0, description=\"a required integer\")\nparser = ArgumentParser()\nsubparsers = parser.add_subparsers()\nbuild_parser(subparsers.add_parser(\"alpha\"), SubConfigA)\nbuild_parser(subparsers.add_parser(\"beta\"), SubConfigB)\nparser.print_help()\n</code></pre> <pre><code>usage: sub_parser.py [-h] {alpha,beta} ...\n\npositional arguments:\n  {alpha,beta}\n\noptional arguments:\n  -h, --help    show this help message and exit\n</code></pre>"},{"location":"#future-works","title":"Future works","text":"<ul> <li>[ ]: High level api such as click</li> <li>[ ]: Options completion for bash</li> </ul>"},{"location":"basic_usage/","title":"Basic usage","text":"01_basic.py<pre><code>from argparse import ArgumentParser\nfrom pydantic import BaseModel, Field\nfrom pydantic_argparse_builder import build_parser\nclass Config(BaseModel):\nstring: str = Field(description=\"string parameter\")\ninteger: int = Field(description=\"integer parameter\")\nparser = ArgumentParser()\nbuild_parser(parser, Config)\nargs = parser.parse_args()\nprint(Config(**vars(args)))\n</code></pre> <pre><code>$&gt; python example.py --string str --integer 10\nstring='str' integer=10\n</code></pre>"},{"location":"introduction/","title":"pydantic-argparse-builder","text":""},{"location":"introduction/#whats-this-library","title":"What's this library","text":"<p>This library that automatically generates <code>ArgumentParser</code> from pydantic <code>BaseModel</code>.</p> <pre><code>from argparse import ArgumentParser\nfrom pydantic import BaseModel, Field\nfrom pydantic_argparse_builder import build_parser\nclass Config(BaseModel):\nstring: str = Field(description=\"string parameter\")\ninteger: int = Field(description=\"integer parameter\")\nparser = ArgumentParser()\nbuild_parser(parser)\nparser.print_help()\n</code></pre> <p>Output:</p> <pre><code>usage: basic.py [-h] --string STRING --integer INTEGER\n\noptional arguments:\n  -h, --help            show this help message and exit\nConfig:\n  --string STRING, -s STRING\n                        a required string\n  --integer INTEGER, -i INTEGER\n                        a required integer\n</code></pre>"},{"location":"introduction/#how-pydantic-argparse-builder-differs-from-other-libraries","title":"How <code>pydantic-argparse-builder</code> differs from other libraries","text":"<p>The <code>pydantic-argparse</code> and <code>pydantic-cli</code> libraries can do similar things.</p> <p>Both can create argument parsers on the basis of classes built with pydantic in the same way. This is very convenient and improves the developer experience because many arguments can be implemented with VSCode completion by creating as an argument.</p> <p>However, there are not easy to use SubParser, argument grouping, exclusive arguments, and so on in complicated ways because of the design that hides ArgumentParser internally. In particular, nested SubParser usage (e.g., <code>aws s3 cp &lt;argument&gt;</code>) seems to be unsupported by any of the libraries.</p>"},{"location":"library_reference/","title":"Library reference","text":""},{"location":"library_reference/#pydantic_argparse_builder.build_parser","title":"<code>pydantic_argparse_builder.build_parser(parser, model, excludes=[], auto_truncate=True, groupby_inherit=True, exclude_truncated_args=['-h'])</code>","text":"<p>Create argument parser from pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>ArgumentParser</code> <p>Argument parser object</p> required <code>model</code> <code>Type[BaseModel]</code> <p>BaseModel class</p> required <code>excludes</code> <code>List[str], optional</code> <p>Exclude field, by default []</p> <code>[]</code> <code>auto_truncate</code> <code>bool, optional</code> <p>Enable truncated parameter such as <code>-h</code>, by default True</p> <code>True</code> <code>groupby_inherit</code> <code>bool</code> <p>If True, inherited basemodels are grouped by class name, by default True</p> <code>True</code> <code>exclude_truncated_args</code> <code>List[str]</code> <p>Exclude truncated arguments, by default [\"-h\"]</p> <code>['-h']</code> <p>Returns:</p> Type Description <code>ArgumentParser</code> <p>Argument parser object</p> Source code in <code>pydantic_argparse_builder\\parse.py</code> <pre><code>def build_parser(\nparser: ArgumentParser,\nmodel: Type[BaseModel],\nexcludes: List[str] = [],\nauto_truncate: bool = True,\ngroupby_inherit: bool = True,\nexclude_truncated_args: List[str] = [\"-h\"],\n) -&gt; ArgumentParser:\n\"\"\"Create argument parser from pydantic model.\n    Parameters\n    ----------\n    parser : ArgumentParser\n        Argument parser object\n    model : Type[BaseModel]\n        BaseModel class\n    excludes : List[str], optional\n        Exclude field, by default []\n    auto_truncate : bool, optional\n        Enable truncated parameter such as `-h`, by default True\n    groupby_inherit: bool, optional\n        If True, inherited basemodels are grouped by class name, by default True\n    exclude_truncated_args: List[str], optional\n        Exclude truncated arguments, by default [\"-h\"]\n    Returns\n    -------\n    ArgumentParser\n        Argument parser object\n    \"\"\"\ngroups = get_groupby_field_names(model) if groupby_inherit else {}\ncache_parsers = {}\nexist_truncate_args = deepcopy(exclude_truncated_args)\nfor name, field in get_model_field(model).items():\nif name in excludes:\ncontinue\nkwargs = {}\n# Set option of multiple arguments\nkwargs.update(**_parse_shape_args(name, field))\n# Set default value\nif field.field_info.default is not Undefined:\nkwargs[\"default\"] = field.get_default()\n# If groupby is enabled, create a new parser for each group\nif name in groups:\ngroup_name = groups[name]\nif group_name not in cache_parsers:\n_parser = parser.add_argument_group(group_name)\ncache_parsers[group_name] = _parser\nelse:\n_parser = cache_parsers[group_name]\nelse:\n_parser = parser\nkwargs[\"help\"] = field.field_info.description\n# Set option args\nif field.type_ is bool:\n# Special case for boolean\ndel kwargs[\"type\"]\nkwargs[\"dest\"] = name\nif field.required:\n# Create both enable and disable option\n_add_both_options(_parser, name, field, kwargs)\nelse:\n# Create either one option.\n_add_either_option(_parser, name, field, kwargs)\nelse:\n# default case for other types\nargs = [f\"--{name.replace('_', '-')}\"]\n# Set truncateiated parameter\nif auto_truncate:\ntruncate_arg = f\"-{name[0]}\"\nif truncate_arg not in exist_truncate_args:\nargs.append(truncate_arg)\nexist_truncate_args.append(truncate_arg)\n_parser.add_argument(\n*args,\nrequired=field.required,\n**kwargs,\n)\nreturn parser\n</code></pre>"},{"location":"library_reference/#pydantic_argparse_builder.main","title":"<code>pydantic_argparse_builder.main()</code>","text":"<p>Start application</p> Source code in <code>pydantic_argparse_builder\\cli.py</code> <pre><code>def main():\n\"\"\"Start application\"\"\"\n# Build parser\nparser = ArgumentParser()\nif len(_registry) == 1:\nbuild_parser(parser, get_command_model(_registry[None]))\nparser.set_defaults(_command=None)\nelse:\nsubparsers = parser.add_subparsers(dest=\"_command\")\nfor command, callback in _registry.items():\nsubparser = subparsers.add_parser(command)\nbuild_parser(subparser, get_command_model(callback))\nargs = parser.parse_args()\nif args._command not in _registry:\nparser.print_help()\nreturn\n# Start application\nkwargs = vars(args)\ncallback = _registry[args._command]\ndel kwargs[\"_command\"]\ncallback(get_command_model(callback)(**kwargs))\n</code></pre>"},{"location":"library_reference/#pydantic_argparse_builder.entrypoint","title":"<code>pydantic_argparse_builder.entrypoint(func)</code>","text":"<p>Decorator for entrypoint of application</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Any</code> <p>Function to be decorated</p> required"},{"location":"library_reference/#pydantic_argparse_builder.entrypoint--example","title":"Example","text":"<pre><code>@entrypoint\ndef main():\n    print(\"Before building argument parsers!\")\n    try:\n        yield\n    except Exception as e:\n        print(\"Error hamdling!\", e)\n    finally:\n        print(\"End!\")\n</code></pre> Source code in <code>pydantic_argparse_builder\\cli.py</code> <pre><code>def entrypoint(func: Any) -&gt; ContextManager[None]:\n\"\"\"Decorator for entrypoint of application\n    Parameters\n    ----------\n    func : Any\n        Function to be decorated\n    Example\n    -------\n        @entrypoint\n        def main():\n            print(\"Before building argument parsers!\")\n            try:\n                yield\n            except Exception as e:\n                print(\"Error hamdling!\", e)\n            finally:\n                print(\"End!\")\n    \"\"\"\n_func = contextmanager(func)\n@wraps(func)\ndef _():\nwith _func():\nmain()\nreturn _\n</code></pre>"},{"location":"library_reference/#pydantic_argparse_builder.command","title":"<code>pydantic_argparse_builder.command(func)</code>","text":"<p>Command decorator for application You can create an application similar to <code>click</code>.</p> <p>Note: This decorator can be used only once.</p>"},{"location":"library_reference/#pydantic_argparse_builder.command--example","title":"Example","text":"<p>example.py</p> <pre><code>from pydantic_argparse_builder import command, main\nclass Config(BaseModel):\n    string: str = Field(description=\"string parameter\")\n    integer: int = Field(description=\"integer parameter\")\n@command\ndef command(config: Config):\n    print(config)\nmain()\n\n$&gt; python example.py --string \"Hello\" --integer 1\nstring='Hello', integer=1\n</code></pre> Source code in <code>pydantic_argparse_builder\\cli.py</code> <pre><code>def command(func: Any):\n\"\"\"Command decorator for application\n    You can create an application similar to `click`.\n    Note: This decorator can be used only once.\n    Example\n    -------\n    example.py\n        from pydantic_argparse_builder import command, main\n        class Config(BaseModel):\n            string: str = Field(description=\"string parameter\")\n            integer: int = Field(description=\"integer parameter\")\n        @command\n        def command(config: Config):\n            print(config)\n        main()\n        $&gt; python example.py --string \"Hello\" --integer 1\n        string='Hello', integer=1\n    \"\"\"\nif len(_registry) &gt; 0:\nraise ValueError(\"Only one command is allowed.\")\n_registry[None] = func\nreturn func\n</code></pre>"},{"location":"library_reference/#pydantic_argparse_builder.sub_command","title":"<code>pydantic_argparse_builder.sub_command(name)</code>","text":"<p>Decorator for sub command</p> Source code in <code>pydantic_argparse_builder\\cli.py</code> <pre><code>def sub_command(name: str):\n\"\"\"Decorator for sub command\"\"\"\ndef _(func: Any):\nif name in _registry:\nraise ValueError(\"Command name is already used.\")\n_registry[name] = func\nreturn func\nreturn _\n</code></pre>"}]}